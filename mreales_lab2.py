# -*- coding: utf-8 -*-
"""mreales_lab2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_P_CEJAW5RiiTUpjQ3IJf73x9lELSUl4

**Grupo: 3**


*   Ardila Ramirez José Daniel
*   Bello López Diana Marcela
*   Reales Gaitán Miguel Ángel

**My own example 1 - Changing in matmul(A, B) Python len(B) (# of rows of B) for len(A[0]) (# of columns of A)**
"""

def matmul(A, B):
    """Multiply matrix A by matrix B."""
    rows_out = len(A)
    cols_out = len(B[0])
    out = [[0 for col in range(cols_out)] for row in range(rows_out)]
    
    for i in range(rows_out):
        for j in range(cols_out):
            for k in range(len(A[0])):
                out[i][j] += A[i][k] * B[k][j]
    return out
matmul(a,b)

"""**My own example 2 - Verifiying error with in matmul(A, B) Python with the original matrices when changing len(B) (# of rows of B) for len(A[0]) (# of colums of A)**"""

def matmul(A, B):
    """Multiply matrix A by matrix B."""
    rows_out = len(A)
    cols_out = len(B[0])
    out = [[0 for col in range(cols_out)] for row in range(rows_out)]
    
    for i in range(rows_out):
        for j in range(cols_out):
            for k in range(len(A[0])):
                out[i][j] += A[i][k] * B[k][j]
                print(B[0][1])
    return out
matmul(a,b)

"""Como podemos ver con el print B[0][1] se está multiplicando por un 5 inexistente y está dando valores ajenos a los que debe dar la multiplicación, porque, se sale del rango :v

**My own example 3 - Chekcing the mtarix multiplication compatibility condition  len(A[0]) == len(B)**
"""

a = [[1, 2, 3],
     [2, 3, 4],
     [5, 6, 7],
     [1, 1, 1]]

b = [[1, 2, 3, 4],
     [2, 3, 4, 5],
     [3, 4, 5, 6]] 

print(a[0])
print(b)
def matmul(A, B):
    """Multiply matrix A by matrix B."""
    rows_out = len(A)
    cols_out = len(B[0])
    out = [[0 for col in range(cols_out)] for row in range(rows_out)]
    
    for i in range(rows_out):
        for j in range(cols_out):
            for k in range(len(B)):
                out[i][j] += A[i][k] * B[k][j]
    return out
matmul(a,b)

"""**My own example 4 - Verifiying error with in matmul(A, B) Python when checking the mtarix multiplication compatibility condition len(A[0]) == len(B)**"""

print(a[0])
print(b)
def matmul(A, B):
    """Multiply matrix A by matrix B."""
    rows_out = len(A)
    cols_out = len(B[0])
    out = [[0 for col in range(cols_out)] for row in range(rows_out)]
    
    for i in range(rows_out):
        for j in range(cols_out):
            for k in range(len(B)):
                out[i][j] += A[i][k] * B[k][j]
    return out
matmul(b,a)

"""**My own example 5 - Deifining A and B that are compatible for multiplcation**

"""

a=[1,2],[3,4]
b=[4,5],[6,7]
def matmul(A, B):
    """Multiply matrix A by matrix B."""
    rows_out = len(A)
    cols_out = len(B[0])
    out = [[0 for col in range(cols_out)] for row in range(rows_out)]
    
    for i in range(rows_out):
        for j in range(cols_out):
            for k in range(len(B)):
                out[i][j] += A[i][k] * B[k][j]
    return out
matmul(a,b)

"""**My own example 6 - Runinng the correct Python matrix multiplication code with the matrices with dimensions compatible for multiplication.**"""

import random
random.normalvariate(0,1)
import random
def random_matrix(m, n):
    out = []
    for row in range(m):
        out.append([random.random() for _ in range(n)])
    return out

randm = random_matrix(2, 3)
randm2 = random_matrix(3, 2)
matmul(randm, randm2)

"""**My own example 7 - Running 10 times matmul(randa, randb) with randa and randb a randon matrices of 600 x 100 and 100 x 600 and calulating the average execution time**"""

B = [[randint(1,10) for j in range(100)] for i in range(600)]
A = [[randint(1,10) for j in range(600)] for i in range(100)]

# Commented out IPython magic to ensure Python compatibility.
# %%time
# for i in range(10):
#   matmul(A,B)

def crono(operacion):
  import time
  idx = 10
  t_average = 0
  for i in range(idx):
    ini = time.process_time()
    out = operacion
    fin = time.process_time()
    t_average += fin - ini
  tprom=np.average(t_average/10)
  return tprom
crono(matmul(A,B))

"""**My own example 8 - Creating the average execution time data frame and adding Python's average execution time**"""

import pandas as pd

def update(df, lenguaje, tiempo):
  dfupdt = pd.DataFrame({'Language':[lenguaje],'Average (s)':[tiempo]})
  return df.append(dfupdt, ignore_index=True)

datos=pd.DataFrame({'Language':[],'Average (s)':[]})
datos= update(datos,"Python",crono(matmul(A,B)))
datos

"""**My own example 9 - Running 10 times randa and randb mutiplicaction as NumPy arrays adding NumPy's average execution time**


"""

import time
import numpy as np
cont=0
for i range(10):
  ar1=np.random.rand(600,100)
  ar2=np.random.rand(100,600)
  inic=time.process_time()
  un=ar1@ar2
fin=time.process_time()
cont=+(fin-inic)
cont/=10
print('The average of ejecution is ')
print(cont)
data=update(data,'Numpy',cont)
data

"""**My own example 10 - Deifining A (2x2)  and B (2x2)**"""

# Commented out IPython magic to ensure Python compatibility.
# %%file euclidian_norm.f90 
# %%fortran
# A=reshape((/4,6,3,2/),(/2,2/))
# B=reshape((/-2,6,4,0/),(/2,2/))

"""**My own example 11 - Defining Fortran subroutine matmul(A,B) for 2x2 matrices**"""

# Commented out IPython magic to ensure Python compatibility.
# %%file euclidian_norm.f90 
# %%fortran
# implicit none
# integer :: n=2
# integer :: A(2,2)
# integer :: B(2,2)
# A=reshape((/4,6,3,2/),(/n,n/))
# B=reshape((/-2,6,4,0/),(/n,n/))
# C=MATMUL(A,B)

"""**My own example 12 -Run Fortran subroutine matmul(A,B) with a and b 2x2 matrices**"""

# Commented out IPython magic to ensure Python compatibility.
# %%file euclidian_norm.f90 
# %%fortran
# implicit none
# integer :: n=2
# integer :: A(2,2)
# integer :: B(2,2)
# A=reshape((/4,6,3,2/),(/n,n/))
# B=reshape((/-2,6,4,0/),(/n,n/))
# integer :: fila=1
# integer :: colum=1
# C(fila,colum)=0
# integer :: k=1
# do while (fila<=n.and.colum<=n)
# C(fila,k)=C(fila,k)+A(fila,colum)*B(colum,fila)
# colum=colum+1
# end do
# do while (fila<=n.and.colum<=n)
# C(k,colum)=C(k,colum)+A(fila,colum)*B(colum,fila)
# fila=fila+1
# end do
# k=k+1
# do while (fila<=n.and.colum<=n)
# C(fila,k)=C(fila,k)+A(fila,colum)*B(colum,fila)
# colum=colum+1
# end do
# do while (fila<=n.and.colum<=n)
# C(k,colum)=C(k,colum)+A(fila,colum)*B(colum,fila)
# fila=fila+1
# end do

"""**My own example 13 - Defining Fortran subroutine matmul(A,B) for 600x100 and 100x600 matrices**"""

SUBROUTINE MTXMLT(A,B,R,N)

IMPLICIT NONE
INTEGER, PARAMETER ::N=2
INTEGER I,J,K

do i = 1,N		
		do j = 1, N	
			R(i,j) = A(i,j) * B(i,j)
		next j
	next i

"""**My own example 14 -Run Fortran subroutine matmul(A,B) with 600x100 and 100x600 matrices**"""

SUBROUTINE MTXMLT(A,B,R,N)

IMPLICIT NONE
INTEGER, PARAMETER ::N=2
INTEGER I,J,K

do i = 1,N		
		do j = 1, N	
			R(i,j) = A(i,j) * B(i,j)
		next j
	next i

"""**My own example 15 - Running 10 times the  Fortran subroutine matmul(A,B) with 600x100 and 100x600 matrices and adding Fortran magic average execution time to the data frame**"""

do i = 1,N		
		do j = 1, N	
			PRINT*, R(i,j)
		next j
	next i
  export XLFRTEOPTS=cpu_time_type=usertime

"""**My own example 16 - Creating a  Fortran program that mutiplies 10 times A(600x100) and  B (100x600) matrices**"""

subroutine MTXMLT(A,B,R,N,L,NMAX)
imlicit none
integer N,L,M,NMAX
real A(NMAX,*)
real B(NMAX,*)
real R(NMAX,*)
integer i,j,k,y
do while (y<=10)
do i=1,N
do j=1,M
R(i,j)=0.0
do k=1,l 
R(i,j)=R(i,j)+A(i,k)*B(k,j)
end do
end do
end do
return 
end do
end

"""**My own example 17 - Running the Fortran program that mutiplies 10 times A(600x100) and  B (100x600) matrices**"""

do i=1,N
  do j=1,M
    R(i,j)=0.0
    do k=1,l 
       print*,R(i,j)
    end do
  end do
end do
return

"""**My own example 18 - Adding Fortran average execution time to the data frame**"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
df = pd.DataFrame(
    {
        "a": np.random.randn(1000),
        "b": np.random.randn(1000),
        "N": np.random.randint(100, 1000, (1000)),
        "x": "x",
    }
)
df
def f(x):
    return x * (x - 1)


def integrate_f(a, b, N):
    s = 0
    dx = (b - a) / N
    for i in range(N):
        s += f(a + i * dx)
    return s * dx
# %timeit df.apply(lambda x: integrate_f(x["a"], x["b"], x["N"]), axis=1)

"""**My own example 19 - Creating a c program that multiplies 10 times A(600x100) and  B (100x600) matrices**"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile matrices.c
# 
# #include <stdio.h>
# #include <stdlib.h>
# #include <time.h>
# 
# int main() {
# int cont=10;
# FILE *dummy1;
# 
#   int A[600][100]; 
#   for(int i = 0; i < 600; i++) {
#     for(int j = 0; j < 100; j++) {
#       A[i][j] = cont+i+j;
#     }
#   }
# 
#   int B[100][600];
#   for(int i = 0; i <100; i++) {
#     for(int j = 0; j < 600; j++) {
#       B[i][j] = cont+i+j;
#     }
#   }
# 
#   int Out[600][600];
#   
# 
#     clock_t ini,fin;
#     double contador=0.0;
#     
#     for(int idx=0; idx<10; idx++){
#         ini= clock();
#         
#         for(int i = 0; i < 600; i++) {
#             //printf("%d ", i);
#             for(int j = 0; j < 600; j++) {
#                 //printf("%d ", j);
#                 Out[i][j]=0;
#                 for(int k = 0; k < 100; k++) {
#                     Out[i][j] += A[i][k] * B[k][j];
#                     //printf("%d ", k);
#                     }
#                 }
#             }
#             fin=clock();
#         contador+= (double) (fin - ini)/CLOCKS_PER_SEC;
#         }
#         contador= contador/10;
#         printf("%f ", contador);
# 
#     dummy1 = fopen("contador_en_c.txt", "w+");
#     fprintf(dummy1,"%f", contador);
#     fclose(dummy1);
# 
#   return 0 ;
# }

"""**My own example 20 - Running the c program that mutiplies 10 times A(600x100) and  B (100x600) matrices**"""

x=!gcc matrices.c -o matrices
x=!./matrices

"""**My own example 21 - Adding c average execution time to the data frame**"""

datos= update(datos,"C",crono(x))
datos

"""**My own example 22 - Creating a C++ program that multiplies 10 times A(600x100) and  B (100x600) matrices**"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile AxB.cc
# 
# #include <stdlib.h>
# #include <iostream>
# #include <time.h>
# 
# using namespace std;
# 
# void AB(int A1[600][100],int B1[100][600]){
#     int i, j, k,idx=0;
#     while(idx>10){
#       for (i = 0; i < 600; i++) {
#         for (j = 0; j < 600; j++) {
#             A1[i][j] = 0;
#             for (k = 0; k < 100; k++)
#                 A1[i][j] += A1[i][k] * B1[k][j];
#         }
#         idx++;
#       }
#     }
#     for (i = 0; i < 600; i++)
#         {
#             for (j = 0; j < 100; j++)
#             {
#                 cout<<"\t"<<A1[i][j];
#             }
#             cout<<"\n\n";
#         }
# }
# 
# int main(void) {
#   int A[600][100];
#   int B[100][600];
# 
#   for (int i = 0; i < 600; i++){
#     for (int j = 0; j < 100; j++){
#       A[i][j] = rand()%15;
#     }
#   }
# 
#   for (int i = 0; i < 100; i++){
#     for (int j = 0; j < 600; j++){
#       B[i][j] = rand()%15;
#     }
#   }
# 	AB(A, B);
# 	return 0;
# }

"""**My own example 23 - Running the C++ program that multiplies 10 times A(600x100) and  B (100x600) matrices**"""

x= !g++ AxB.cc -o AxB
x= !./AxB

"""**My own example 24 - Adding C++ average execution time to the data frame**"""

datos= update(datos,"C++",crono(x))
datos

"""**My own example 25 - Creating a Java program that multiplies 10 times A(600x100) and  B (100x600) matrices**"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile AporB.java
# 
# import java.lang.*;
# import java.io.FileWriter;
# import java.io.IOException;
# 
# class AporB {
# 
#   public static void main(String[] args) {
#       
# int idx1=10;
# 
#   int [][] A = new int[600][100];
#   for(int i = 0; i < 600; i++) {
#     for(int j = 0; j < 100; j++) {
#       A[i][j] = idx1+i+j;
#     }
#   }
# 
#   int [][] B = new int[100][600];
#   for(int i = 0; i <100; i++) {
#     for(int j = 0; j < 600; j++) {
#       B[i][j] = idx1+i+j;
#     }
#   }
# 
#   int [][] out = new int[600][600];
#   
# 
#     long ini ,fin ;
#     double delta=0.0;
#     
#     for(int idx2=0; idx2<10; idx2++){
#         ini= System.currentTimeMillis();
#         
#         for(int i = 0; i < 600; i++) {
#             //printf("%d ", i);
#             for(int j = 0; j < 600; j++) {
#                 //printf("%d ", j);
#                 out[i][j]=0;
#                 for(int k = 0; k < 100; k++) {
#                     out[i][j] += A[i][k] * B[k][j];
#                     //printf("%d ", k);
#                     }
#                 }
#             }
#             fin=System.currentTimeMillis();
#         delta+= fin - ini/1000;
#         }
#         delta= delta/10;
#         System.out.println(delta);
#         
#         try {
#         FileWriter file1 = new FileWriter("java_delta.txt");
#         file1.write(Double.toString(delta));
#         file1.close();}
#       catch (IOException e) {
#           e.printStackTrace();
#       }
# 
#   return ;
#   }
# }

"""**My own example 26 - Running the Java program that multiplies 10 times A(600x100) and  B (100x600) matrices**"""

x=!javac AporB.java
x=!java AporB

"""**My own example 27 - Adding Java average execution time to the data frame**"""

datos= update(datos,"Java",crono(x))
datos

"""**My own example 28 - Creating a Javascript program that multiplies 10 times A(600x100) and  B (100x600) matrices**"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile AporBdiez.js
# const { performance } = require('perf_hooks');
# const fs = require("fs");
# 
# var idx1=10;
# 
#   let A = [];
#   for(let i = 0; i < 600; i++) {
#     A[i]=0;
#     for(let j = 0; j < 100; j++) {
#       A[i][j] = idx1+i+j;
#     }
#   }
# 
# 
#   let B = [];
#   for(let i = 0; i < 100; i++) {
#     B[i]=0;
#     for(let j = 0; j < 600; j++) {
#       B[i][j] = idx1+i+j;
#     }
#   }
# 
# let out = [];
#  
# var delta=0.0;
# let ini =0;
# let fin =0;
#     
#     for(let idx2=0; idx2<10; idx2++){
#         ini =performance.now();
#         
#         for(let i = 0; i < 600; i++) {
#           out[i]=0;
#             for(let j = 0; j < 600; j++) {
#                 out[i][j]=0;
#                 for(let k = 0; k < 100; k++) {
#                     out[i][j] += A[i][k] * B[k][j];
#                     }
#                 }
#             }
#         fin = performance.now();
#         delta+= fin - ini;
#          }
# delta= (delta/1000);
# console.log(delta);

"""**My own example 29 - Running the Javascript program that mutiplies 10 times A(600x100) and  B (100x600) matrices**"""

x=!node AporBdiez.js

"""**My own example 30 - Adding Javascript average execution time to the data frame**"""

datos= update(datos,"Javascript",crono(x))
datos

"""**My own example 31 - Finding the minimun average execution time in the data frame**"""

avgmin=min(datos["Average (s)"])
avgmin

"""**My own example 32 - Adding the Speed factor column to the data frame**"""

datos["Speed Factor"]=datos["Average (s)"]/avgmin

"""**My own example 33 - Sorting the the data frame by average execution time**"""

datos.sort_values(by=['Average (s)'])
datos